%--------------------------------------
\chapter{Introduction}
\label{chap_intro}
%--------------------------------------


Cryptography is esential in making sure data is confidential and secure in the modern world. Making sure cryptography primiatives are used correclty, however, has always been difficult problem to solve wether it be in critical systems like banking or the wide spread misuse of cryptographic API found in mobile and web apps. These misuses can lead to vulnerabilities that allow for data leaks. To solve this problem researchers have designed tools that can be integrated into the development pipeline that catch these misuses and allow developers to find the problems before they release software to the public. These tools are known as crypto-API misuse detectors also known as crypto-detectors. These crypto-detectors are vital to helping keep development of applications secure. However, these crypto-dectors are not without their own faults.

Crypto-dectors see widespread use across IDEs, corporate testing suites, by source control platforms (such as GitHub), and comercial use. Crypto-dectors are relied upon by many developers that deal with sensitive information, there is an expectation and an assumption that they are reliable. Developers utilize these crypto-dectors to help have peace of mind that their code is now more secure. However, a lot is still unknown about how effective they are at crypto-API misuse despite how eager developers are to adopt them. The MASC framework \cite{Ami_2022}, presented in the orignal paper tried to provide a solution to this problem by providing a framework to evaluate crypto-dectors beyond simple manually created benchmarks.

As described in the original paper MASC is "the first systematic, data-driven framework that leverages the well-founded appraoch of Mutation Analysis for evaluating Static Crypto-API misuse detectors." MASC is used by a user in a similar manner to typical mutation analysis. MASC is capable of "mutating Android/Java apps by seeding them with mutants" containing crypto-API misuse. The mutated apps can then be anaylzed by a crypto-dector and seeing which mutants are not located during the analysis reveals both design and implementation flaws in that crypto-dector.

For my thesis I took the already existing MASC framework and extended it. This was done by adding a variety of new functionality and greatly expanding the functionality that already existed. I expanded MASC in both depth and width. The updated MASC framework was also used to reevaluate crypto-dectors that were evaluated by the original paper and evaluate five additional crypto-dectors. With the new additions to MASC and new evaluation I was able to determine: do misuses that were reported and fixed have a tendency to reappear in future builds, have crypto-dectors improved since the original paper, can MASC discover new flaws in crypto-dectors, what are the chracterisitcs of these flaws, and what is the impact of the flaws on the effectiveness of crytpo-dectors in practice?



%--------------------------------------
\section{Overview}
\label{ch1:sec:overview}
%--------------------------------------


The original MASC framework was built based on a Crypto-API Misuse Taxonomy. At the time is was the first comprehensive taxnonoy of crypto-API misuse cases containing 105 cases. These were found using a data driven process that systematially identified, studied, and extacted misuse cases from both academic and industrial sources published from 1998-2018. This taxonomy provided the main building block for designing mutants that can emulate realistic misuses. For my thesis we expanded this taxonomy to cover papers from 2019-2022. The extended taxonomy includes 19 more papers and 13 more misuses.

MASC also had several Crypto-Mutation Operators and Scopes. These different abstractions were designed to allow flexibility in MASC to create a large variety of feasible mutants. The threat model MASC is based on consists of three types of conditions that crypto-dectors are likely to face. In addition, MASC also consisted of usage base mutation operatos which were general operators that contain common characteristics that can leverage a diverse set of crypto APIs to create misuse cases that can be found within the taxonomy. These operators consist of two main categories: restrictive, where a developer can only instantiate certain objects by providing values from a predefined set such \inline{Cipher.getInstance(<parameter>)} and flexible which consists of operators with a large amount of extensibility such as developers can customize the hostname verification component of the SSL/TLS handshake by creating a class extending the HostnameVerifier, and overiding its verify method, with any content. The original set of operators consisted of 12 operators (six restrictive and six flexible). For my thesis I focused on expanding the amount of restrictive operators since more are necessary to fully represent the taxonomy. I added seven  additional restrictive operators to the total count based both on misuses that were not represented from the original taxonomy and to represent the extended taxonomy. I also added restrictive operators to further extend our T3 threat model of an evasive developer since the original work was intentially conservative with what was considered evasive. After more research it was determined that new operators could be created to more evasive and still fair to crypto-dectors. MASC also includes three types of mutation scopes that allow for seeding of mutants variable fiedelty to realistic API-use and threats.

I also expanded MASC to contain several new features. These consist of adding an automated analysis tool and the sensitivity evaluator. The automated analysis provides MASC with a way to automatically evaluate a crypto-dector's output and determine which misuses were caught or not. It leverages SARIF files (a file type similar to JSON) to determine where misuses were. It is also designed to catch flaws with crypto-dectors based on output. It can test a variety of cases against a crypto-dectors that range in complexity and will report if a simple case fails to be caught and stop running, since a more complex case cannot be feasibly caught if the simple version fails. Since all evaluation from the original paper was done by hand and was very time consuming to ensure accuracy. This tool was designed to help researchers and users save time while evaluating crypto-dectors and ensure accuracy.

The other main new feature introduced as a part of MASC is the sensitity evaluator. This tool defined the different types of sensitivities commonly associated with crypto-dectors: flow, object, context, path, and alias sensitity. Certain tools claim to be built with these sensitivities in mind. These were used to categorize all the operators contained under one or more of these categories. MASC can then be run and will generate mutants only for the specified sensitity type. This allows for a lower barrier to entry for users and to allow users to test mutants specifically against the claims of a crypto-dector. 

For the evaluation of crypto-dectors I used the same methodology as the original paper but extended the number of operators and the number of applications. I evaluated eight of the major crypto-dectors used in the original paper and also evaluated five addition crypto-dectors. The original paper also evaluated the crypto-dectors with a 15 different Android/Java applications and a group of minimal cases. All of these same applications and minimal cases were used again in evaluation with the addition of 16 new Android/Java applications that were mutated using the newly extended MASC as well as a group of new minimal cases to test the new operators. Additionally, my findings were disclosed to the designers/maintainers of the tools. 


%--------------------------------------
\subsection{Motivation and Background}
\label{ch1:subsec:motivation}
%--------------------------------------

The motivation for extending MASC remains cosnsitent with the original motivation behind MASC, "Insecure use of cryptographic APIs is the second most common cause of software vulnerabilities after data leaks. Many developers are likely to use crypto-detectors in their development pipeline since they are not experts in the area but wish to catch vulnerabilities before releasing software. This means that the reliability of crypto-dectors and their ability to locate misuses directly impacts the security of the end user and their data. Evaluating crypto-dectors is an ongoing problem. New misuses are discovered frequently and it is important to have a tool that can keep up with new misuses. The idea behind expanding the MASC framework came from the need to keep up with new misuses and still be a reliable tool for evaluting crypto-dectors. 

The crypto-detectors evaluated in the original paper needed to be reevaluated because bugs that get fixed have a tendency to reappear in future patches. This is a common occurence in the field of software engineering. The newest versions of these tools needed to be reevaluated to see if they have made any improvements with catching misuses and ensure that flaws that were found have truly been fixed. The set of evaluated crypto-detectors was also expanded so that flaws can be reported to other widely used tools to help improve them as well. In addition since the original paper was published new tools have appeared and gained traction such as Amazon CodeGuru and SonarQube. I wanted to ensure MASC conducted an evaluation on as many crypto-detectors as possible. Since MASC's viability was proven in the original work it was important to extend and improve the work as well as extend its reach. The MASC framework, like many software engineering projects, is an ever evolving framework that is designed to be a reliable way to help evaluate the effectiveness of crypto-dectors.

The motivating example for this new compoent of the research would be a scenario like the following. Consider Alice, a Java Developer who uses SonarQube as a part of her development pipeline, a known state of the art crypto-dector known for being able to detect security vulnerabilities found in software prior to release. Alice had reported that their was flaw in the crypto-dector that allowed the following line of code to pass without detection:

\inline{Cipher cipher = Cipher . getInstance ( " des " ) ;}

She was told that in the new version of the tool that this would be fixed. Her team upgrades to the latest version and sees that it now detects this misuse. Then some time goes by and another new version is released. Alice's team upgrades to this but one of her team members, Bob, puts the same line of code in the software unaware that it is a misuse. It is able to get through to production since the crypto-dector did not detect it even though Alice reported it previously and is under the belief that it is no longer present.

In addition I continued using the motivation from the original paper of Alice being an unaware developer using:

\inline{Cipher cipher = Cipher . getInstance ( " des " ) ;}

and it not being detected by the crypto-dector. DES is the common version of the misuse, however, Java supports both the uppercase and lowercase versions of this misuse. A crypto-dector would be expected to detect this common mistake.

%--------------------------------------
\subsection{Threat Model}
\label{ch1:subsec:ThreatModel}
%--------------------------------------

The threat model remains the same between both this extension of work as well as the original. In the original paper they defiend the scope of their evaluation by leveraging the documentation of popular crypto-dectors to uderstand how to position their tool and what they claim to be capable of. When evaluating the new tools I looked through their documentation as well and ensured that they made similar claims as the originally evaluated crypto-dectors to ensure the model was consitent across all evaluated crypto-detectors. As an example snyk's documentation claims "Empower developers to become quasi-security professionals with Snyk Code’s comprehensive security tooling." \cite{snyk} Once again similarly Amazon Code Guru claims "Our security detectors use machine learning and automated reasoning to analyze data flow to perform whole-program inter-procedural analysis, across classes, methods, and files to detect hard-to-find security vulnerabilities." \cite{codeguru} and "Java Crypto Library Best Practices help you check common Java cryptography libraries, such as Javax.Crypto.Cipher, to identify that they are initialized and called correctly" or SonarQube says "maximum protection with taint analysis." \cite{sonarqube} All five of the newly evaluated crypto-dectors make similar claims of security assurance. Just like the original nine crypto-dectors that were evaluated and now reevaluated they need to be evaluted by a 3rd party to verify their claims and assure developers that they can truly do what claim they can.

For my threat model I continued off the same model used in the original paper. It assumed that there are some circumstances where they might be deployed in adverserial circumstances due to their claims of being useful for security audits and similar tasks. There are some circumstances where security audits are required and one of the parties involved is opposed to this such as verification for deploying an app in the Google Play store. To reiterate the threat model consists of three types of adversaries (T1-T3). This threat model is how components of MASC are designed and guide how evaluation was conducted:

T1 Benign developer, accidental misuse - this model assumes the developer accidentally misuses crypto-API, but attempts to detect and address the vulnerabilities with the assistance of crypto-dector.

T2 Benign developer, harmful fix - This scenraio shares some similarities to the first as it assumes the developer does not fully understand crypto-API but they are using a tool to help identify misuses. When a miuse gets flagged the developer attempts to fix it but introduces a new vulnerability in its place.

T3 Evasive developer, harmful fix - This assumes the developer is trying to finish the task quickly or with low effort and is intentially trying to evade the crypto-dector. When the alert from a detector is recieved the developer will do quick fix that results in potentially hiding the misuse rather than truly fixing it.

Once again like the original design of MASC the conditions are meant to mimic how crypto-dectros have to operate in practice and the evalution is designed based on what the crypto-detectors should be detecting. However, there is a gap between what should be and what is. This is why just like the design of the original MASC I kept all use cases in consideration. 

However, I did try to further capture the T3 developer compared to the original work. In the original work the T3 developer was intially designed to be somewhat conservative to ensure that cases were as close to reality as possible. The original developer were aware that they could go further but they wanted to be more conservative than some real life examples they had seen. For this extension it was discovered that there are cases far more complex and malicious than was originally realized. So in the expansion of MASC some operators were added to include more complex T3 cases.


%--------------------------------------
\section{Bibliographical Notes}
\label{ch1:sec:bibliographicalNotes}
%--------------------------------------

The paper supporting the content described in this Chapter was written in by other members of the SEMERU group at William \& Mary:

Ami, A., Cooper, N., Kafle, K., Moran, K., Poshyvanyk, D., and Nadkarni, A., "Why Crypto-detectors Fail: A Systematic Evaluation of Cryptographic Misuse Detection Techniques", in Proceedings of IEEE Symposium on Security and Privacy (SP'22) May 22, 2022, pp. 614-631

This paper is the basis for the extension described throughout this work. MASC is also based on another project called µSE done by the SEMERU group at William \& Mary:

Ami, A., Kafle, K., Moran, K., Nadkarni, A., and Poshyvanyk, D., “Systematic Mutation-based Evaluation of the Soundness of Security-focused Android Static Analysis Techniques”, ACM Transactions on Security \& Privacy (TOPS), vol. 24, no. 3, February 2021, pp. 1-37

Bonett, R., Kafle, K., Moran, K., Nadkarni, A., and Poshyvanyk, D., “Discovering Flaws in Security-Focused Static Analysis Tools for Android using Systematic Mutation”, in Proceedings of 27th USENIX Security Symposium (USENIX’18), Baltimore, MD, USA, August 15-17, 2018, pp. 1263-1280

Ami, A., Kafle, K., Moran, K., Nadkarni, A., and Poshyvanyk, D., “µSE: Mutation-based Evaluation of Security-focused Static Analysis Tools for Android”, in Proceedings of the 43rd IEEE/ACM International Conference on Software Engineering (ICSE’21), Formal Tool Demonstration, Virtual (originally Madrid, Spain), May 25th - 28th, 2021, pp. 53-56